---
layout: post
title: My First AWS Adventure - Building a Web App with S3, Lambda and CloudFront
description: >

sitemap: false
hide_last_modified: true
---
<img src="/assets/img/blog/aws.png" width="800" />

Starting something new can be a little overwhelming, and that’s exactly how I felt when I first tackled Amazon Web Services (AWS). But after one month of hands-on experience, I’ve learned a ton of practical lessons that I can’t wait to share. 

In this post, I’ll walk you through my journey and offer a practical overview for anyone just starting out with AWS, based on my own experience diving into the platform. This might also serve as a helpful starting point for those looking for a hands-on project to begin with, just like I did.

To start, I should mention that I came into this with zero experience in AWS or any other cloud services. However, I was eager to learn, and that enthusiasm really drove me to explore the possibilities.

I kicked off my learning by enrolling in the **AWS Cloud Technical Essentials** course on Coursera ([link here](https://www.coursera.org/learn/aws-cloud-technical-essentials)), which is offered directly by AWS. I found it to be an excellent introduction, and I highly recommend it to anyone new to the platform.

As I worked through the course, I decided to challenge myself with a project beyond the scope of the exercises provided. I began working on a straightforward web application that enables users to upload, store images, and run object detection algorithms on them. This project quickly became my hands-on playground, where I could test and solidify the concepts I was learning in real time. I was thrilled to dive into a variety of AWS services, like S3, Lambda, CloudFront, and API Gateway (more on these later), and experiment with how they could come together.

Before we begin, I’d like to address a few key points. The implementation described in this post was done with a root account, as account management wasn't my primary focus. However, it’s worth noting that this is not the recommended approach according to AWS guidelines. 
Additionally, since I’m still learning, some parts of the implementation might not be the most efficient. But ultimately, the purpose here is to learn, experiment, and share my experiences—mistakes included! Any feedback or suggestions are always welcome.

## Managing Your AWS Budget

Before you dive into the implementation details,  I suggest setting a cost budget right away. AWS offers a free tier for most services, so you can explore and learn without worrying about charges. However, it's easy to accidentally use paid services, so email alerts are a great way to keep track and prevent surprises.

You can set this up through the "Billing and Cost Management" console. 

<img src="/assets/img/blog/s1.png" width="600" />


Scroll down to the "Budgets and Planning" section, click on "Budgets," and select "Create budget" to set everything up.

<img src="/assets/img/blog/s2.png" width="600" />
<img src="/assets/img/blog/s3.png" width="600" />

All that's left is to set your maximum budget for AWS and enter the email address where you'd like to receive notifications. You can start with a pre-configured AWS template, such as the "Zero spend budget", which will notify you if your charges exceed $0.01 (above the AWS Free Tier limits). Feel free to customize your budget settings and experiment; it's really simple to do!

And here’s an example of an alert email you'll receive from AWS when your spending exceeds the predefined budget.

<img src="/assets/img/blog/s4.png" width="800" />

## Application Architecture 

The architecture of my application is a typical 3-tier application on AWS, also covered in the course mentioned in the introduction of this post. The architecture consists of:
- **Presentation Layer**: The user interface (HTML) is hosted on Amazon Simple Storage Service (Amazon S3) and delivered through Amazon CloudFront for fast, global content distribution.
- **Application Layer**: AWS Lambda handles the application logic, with separate functions dedicated to tasks such as user authentication, uploading images to S3, and running object detection algorithms.
- **Data Layer**: This layer stores and manages the application’s data. In this case, we’re using Amazon S3 to handle the data storage.

I’ve broken down the process into three main parts:

- **Setting up basic authentication for your static website on S3**
- **Using a Lambda function to upload images to S3**
- **Implementing object detection with Lambda functions**

Now, let’s explore how we can bring this to life on AWS.

## 1. Setting Up Basic Username and Password Authentication for a Static Website on S3

### Set Up an S3 Bucket

In the AWS search bar, search for S3 and navigate to the corresponding console, where you can click on "Create bucket". You'll be asked to configure some bucket settings, but for this application, you can stick with the default options. 
<img src="/assets/img/blog/s5.png" width="800" />

One important thing to mention is that the "Block all public access" option must remain enabled (this is the default setting) to ensure that the bucket stays private.

<img src="/assets/img/blog/s6.png" width="800" />

While S3 offers an option to enable static website hosting after creating the bucket, we’ll skip this feature and instead use AWS CloudFront to serve the website. Typically, combining S3 with CloudFront is considered one of the best solutions for hosting and delivering static content.

CloudFront offers superior flexibility and performance compared to S3 alone. For example, CloudFront reduces latency by using edge locations. S3 buckets are region-specific, meaning that no matter where the user is, the website will always be served from the region where the S3 bucket is located. In contrast, CloudFront ensures that content is delivered from the nearest edge location, speeding up load times and enhancing the overall user experience.

### Upload the index.html to Your S3 Bucket

Now it’s time to upload the HTML file for your website’s frontend to the S3 bucket. Since frontend development isn’t my strong suit, I simply provided ChatGPT with detailed instructions and made a few tweaks to the generated HTML to get it just right.

Once you're happy with your website, go to your S3 bucket, and then simply click on the "Upload" button to start adding your file.

Here’s a sneak peek of the design and layout of my simple website.

<img src="/assets/img/blog/s7.png" width="600" />

The website includes also some basic functionalities, such as image preview before uploading.
<img src="/assets/img/blog/s8.png" width="600" />


### Configure a CloudFront Distribution

In the AWS search bar, search for CloudFront and navigate to the corresponding console, where you can click on "Create distribution".

In this step, we have various configuration options to set up. You need to connect the CloudFront distribution to both the S3 bucket (which will act as the distribution's origin) and the Lambda function for authentication. Let’s break down how to do this.

During the distribution creation, make sure to select the previously created S3 bucket in the "Origin Domain" field.

In the "Origin Access" section, select "Origin access control settings (recommended)" and choose your S3 bucket again. This ensures CloudFront can securely access your bucket while preventing direct access.

<img src="/assets/img/blog/s9.png" width="1000" />

In the "Default Cache Behavior" section, select "Redirect HTTP to HTTPS" to ensure all traffic is securely redirected.

<img src="/assets/img/blog/s10.png" width="1000" />
### Create the Lambda Function for Authentication


~~~js
export const handler = async (event) => {
   // Retrieve the CloudFront request object
   console.log("Lambda function invoked");
   const request = event.Records[0].cf.request;
  
   let isAllowedAccess = false;  // Default to false


   // Check if the 'Authorization' header is present
   if (request.headers && request.headers.authorization) {
       const basicAuthHeader = request.headers.authorization[0].value;
      
       // Expected base64-encoded "username:password"
       const authString = "Basic " + Buffer.from("mariadancianu:ADD-PASSWORD-HERE").toString("base64"); // Replace with your username and password


       // Compare the provided auth string with the expected one
       isAllowedAccess = basicAuthHeader === authString;
   }


   // If access is allowed, return the original request (continue processing)
   if (isAllowedAccess) {
       console.log("Access granted.");
       return request;
   }


   // If access is not allowed, return a 401 Unauthorized response with WWW-Authenticate header
   const response = {
       status: '401',
       statusDescription: 'Unauthorized',
       body: JSON.stringify("Access denied! Please provide valid credentials."),
       headers: {
           "www-authenticate": [{ key: "WWW-Authenticate", value: "Basic" }]
       },
   };
   console.log("Access denied. Please provide valid credentials.");
   return response;  // Return 401 Unauthorized response
};

~~~


## 2. Using a Lambda Function to Upload Images to S3


~~~js
const AWS = require('aws-sdk');
const s3 = new AWS.S3();

exports.handler = async (event) => {
  const bucketName = 'YOUR-BUCKET-NAME-HERE';
  
  try {
    // Parse the base64-encoded image from the event body
    const image = JSON.parse(event.body).body;
    const imageBuffer = Buffer.from(image, 'base64');
    
    // S3 upload parameters
    const params = {
      Bucket: bucketName,
      Key: `${Date.now()}.png`,  // Unique key using the current timestamp
      Body: imageBuffer,
      ContentType: 'image/png'   // Image MIME type
    };
    
    // Upload the image to S3
    await s3.putObject(params).promise();
    
    // Return a success response
    return {
      statusCode: 200,
      body: JSON.stringify({ message: 'Image uploaded successfully.' })
    };
  } catch (error) {
    // Handle any errors and return an error response
    return {
      statusCode: 500,
      body: JSON.stringify({ message: 'An error occurred while uploading the image.', error: error.message })
    };
  }
};

~~~


## 3. Running Object Detection via Lambda Function



